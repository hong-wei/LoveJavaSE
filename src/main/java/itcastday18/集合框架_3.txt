泛型：
	jdk1.5出现的安全机制。
	
好处：
	1，将运行时期的问题ClassCastException转到了编译时期。
	2，避免了强制转换的麻烦。
	
<>:什么时候用？当操作的引用数据类型不确定的时候。就使用<>。将要操作的引用数据类型传入即可.
   其实<>就是一个用于接收具体引用数据类型的参数范围。
   
在程序中，只要用到了带有<>的类或者接口，就要明确传入的具体引用数据类型 。

泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。

运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。
为什么擦除呢？因为为了兼容运行的类加载器。

泛型的补偿：在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。


泛型的通配符：? 未知类型。 

泛型的限定：
? extends E: 接收E类型或者E的子类型对象。上限
一般存储对象的时候用。比如 添加元素 addAll.

? super E: 接收E类型或者E的父类型对象。 下限。
一般取出对象的时候用。比如比较器。

===========================================================

集合的一些技巧：

需要唯一吗？
需要：Set
	需要制定顺序： 
			需要： TreeSet
			不需要：HashSet
			但是想要一个和存储一致的顺序(有序):LinkedHashSet
不需要：List
	需要频繁增删吗？
		需要：LinkedList
		不需要：ArrayList
		
如何记录每一个容器的结构和所属体系呢？

看名字！


List
	|--ArrayList
	|--LinkedList

Set
	|--HashSet
	|--TreeSet

后缀名就是该集合所属的体系。

前缀名就是该集合的数据结构。

看到array：就要想到数组，就要想到查询快，有角标.	
看到link ：就要想到链表，就要想到增删快，就要想要 add get remove+frist last的方法 
看到hash : 就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashcode方法和equals方法。 
看到tree ：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。

而且通常这些常用的集合容器都是不同步的。 

